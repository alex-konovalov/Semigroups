#############################################################################
##
#W  semigrp.gi
#Y  Copyright (C) 2013-15                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

#############################################################################
## This file contains methods for finite semigroups which do not depend on
## whether they are acting or not, i.e. they should work for all semigroups.
## It is organized as follows:
##
##   1. Helper functions
##
##   2. Generators
##
##   3. Semigroup/Monoid/InverseSemigroup/InverseMonoidByGenerators
##
##   4. RegularSemigroup
##
##   5. ClosureSemigroup and ClosureInverseSemigroup
##
##   6. Subsemigroups
##
##   7. Random semigroups and elements
##
##   8. Changing representation: AsSemigroup, AsMonoid
##
#############################################################################

#############################################################################
## 1. Helper functions
#############################################################################

# Returns an isomorphism from the semigroup <S> to a semigroup in <filter> by
# composing an isomorphism from <S> to a transformation semigroup <T> with an
# isomorphism from <T> to a semigroup in <filter>, i.e.  <filter> might be
# IsMaxPlusMatrixSemigroup or similar.

SEMIGROUPS.DefaultIsomorphismSemigroup := function(filter, S)
  local iso1, inv1, iso2, inv2;

  iso1 := IsomorphismTransformationSemigroup(S);
  inv1 := InverseGeneralMapping(iso1);
  iso2 := IsomorphismSemigroup(filter, Range(iso1));
  inv2 := InverseGeneralMapping(iso2);

  return MagmaIsomorphismByFunctionsNC(S,
                                       Range(iso2),
                                       x -> (x ^ iso1) ^ iso2,
                                       x -> (x ^ inv2) ^ inv1);
end;

# Returns an isomorphism from the monoid (or IsMonoidAsSemigroup) <S> to a
# monoid in <filter> by composing an isomorphism from <S> to a transformation
# monoid <T> with an isomorphism from <T> to a monoid in <filter>, i.e.
# <filter> might be IsMaxPlusMatrixMonoid or similar.

SEMIGROUPS.DefaultIsomorphismMonoid := function(filter, S)
  local iso1, inv1, iso2, inv2;

  iso1 := IsomorphismTransformationMonoid(S);
  inv1 := InverseGeneralMapping(iso1);
  iso2 := IsomorphismMonoid(filter, Range(iso1));
  inv2 := InverseGeneralMapping(iso2);

  return MagmaIsomorphismByFunctionsNC(S,
                                       Range(iso2),
                                       x -> (x ^ iso1) ^ iso2,
                                       x -> (x ^ inv2) ^ inv1);
end;

# Returns the semigroup generated by <S> and <coll> and may change <S> in
# place, so this should only be used in a function where <S> is created.

SEMIGROUPS.AddGenerators := function(S, coll, opts)
  local T;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll))
      or not IsGeneratorsOfSemigroup(Concatenation(GeneratorsOfSemigroup(S),
                                                   coll)) then
    ErrorNoReturn("Semigroups: SEMIGROUPS.AddGenerators: usage,\n",
                  "the arguments do not belong to the same family,");
  fi;

  if IsActingSemigroup(S)
      or (IsTransformationSemigroup(S) and DegreeOfTransformationSemigroup(S)
          <> DegreeOfTransformationCollection(coll))
      or (IsPartialPermSemigroup(S) and
          (DegreeOfPartialPermSemigroup(S) <>
           DegreeOfPartialPermCollection(coll)
           or CodegreeOfPartialPermSemigroup(S) <>
           CodegreeOfPartialPermCollection(coll))) then
           # FIXME the above should really be less than, since this should
           # work if the degree of the semigroup is larger than the degree of
           # the collection!
    return ClosureSemigroup(S, coll, opts);
  fi;

  # Note that EN_SEMI_ADD_GENERATORS only checks if the generators coll already
  # belong to the semigroup, it does not perform any further enumeration of the
  # semigroup. So, in the small generating set code of
  # Semigroup/MonoidByGenerators we must check if elements of the collection
  # belong to the semigroup before trying to add them.
  if EN_SEMI_ADD_GENERATORS(S, coll) = fail then
    return ClosureSemigroup(S, coll, opts);
  fi;
  # We must recreate the semigroup <S> as <T> since <S> may have further
  # attributes that are no longer valid after the call to
  # EN_SEMI_ADD_GENERATORS, such as Size etc. In other words, S may no longer
  # be valid after calling this function if any new generators are added.
  T := Semigroup(GeneratorsOfMagma(S), opts);
  T!.__en_semi_cpp_semi := S!.__en_semi_cpp_semi;
  T!.__en_semi_fropin   := S!.__en_semi_fropin;
  return T;
end;

#############################################################################
## 2. Generators
#############################################################################

InstallMethod(IsGeneratorsOfInverseSemigroup,
"for a semigroup with generators",
[IsSemigroup and HasGeneratorsOfSemigroup],
function(S)
  if IsSemigroupWithInverseOp(S) then
    return true;
  fi;
  return IsGeneratorsOfInverseSemigroup(GeneratorsOfSemigroup(S));
end);

InstallMethod(Generators, "for a semigroup",
[IsSemigroup],
function(S)

  if HasGeneratorsOfMagmaIdeal(S) then
    return GeneratorsOfMagmaIdeal(S);
  elif HasGeneratorsOfGroup(S) then
    return GeneratorsOfGroup(S);
  elif HasGeneratorsOfInverseMonoid(S) then
    return GeneratorsOfInverseMonoid(S);
  elif HasGeneratorsOfInverseSemigroup(S) then
    return GeneratorsOfInverseSemigroup(S);
  elif HasGeneratorsOfMonoid(S) then
    return GeneratorsOfMonoid(S);
  fi;

  return GeneratorsOfSemigroup(S);
end);

#############################################################################
## 3. Semigroup/Monoid/InverseSemigroup/InverseMonoidByGenerators
#############################################################################

InstallImmediateMethod(IsTrivial, IsMonoid and HasGeneratorsOfMonoid, 0,
function(S)
  local gens;
  gens := GeneratorsOfMonoid(S);
  if CanEasilyCompareElements(gens) and Length(gens) = 1
      and gens[1] = One(gens) then
    return true;
  fi;
  TryNextMethod();
end);

InstallImmediateMethod(IsTrivial, IsMonoid and HasGeneratorsOfSemigroup, 0,
function(S)
  local gens;
  gens := GeneratorsOfSemigroup(S);
  if CanEasilyCompareElements(gens) and Length(gens) = 1
      and gens[1] = One(gens) then
    return true;
  fi;
  TryNextMethod();
end);

InstallMethod(MagmaByGenerators,
"for a finite multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite], SemigroupByGenerators);

InstallMethod(SemigroupByGenerators,
"for a finite multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite],
function(coll)
  return SemigroupByGenerators(coll, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(SemigroupByGenerators,
"for a finite multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local n, S, SemigroupsAddGenerators, filts, i, x;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);

  if CanEasilyCompareElements(gens) then
    # Check if the One of the generators is a generator
    if IsMultiplicativeElementWithOneCollection(gens)
        and Position(gens, One(gens)) <> fail then
      return MonoidByGenerators(gens, opts);
    fi;

    # Try to find a smaller generating set
    if opts.small and Length(gens) > 1 then
      gens := Shuffle(Set(gens));
      if IsGeneratorsOfActingSemigroup(gens) then
        n := ActionDegree(gens);
        Sort(gens, function(x, y)
                     return ActionRank(x, n) > ActionRank(y, n);
                   end);
      else
        Sort(gens, IsGreensDLeq(Semigroup(gens)));
      fi;

      opts := ShallowCopy(opts);
      opts.small := false;
      opts.regular := false;

      S := Semigroup(gens[1], opts);

      SemigroupsAddGenerators := SEMIGROUPS.AddGenerators;

      if InfoLevel(InfoSemigroups) > 1 then
        n := Length(gens);
        for i in [2 .. n] do
          if not gens[i] in S then
            S := SemigroupsAddGenerators(S, [gens[i]], opts);
          fi;
          Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
                " generators so far\n");
        od;
      else
        for x in gens do
          if not x in S then
            S := SemigroupsAddGenerators(S, [x], opts);
          fi;
        od;
      fi;
      return S;
    fi;
  fi;

  filts := IsSemigroup and IsAttributeStoringRep;

  if opts.acting and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
    if opts.regular then
      filts := filts and IsRegularSemigroup;
    fi;
  elif IsGeneratorsOfEnumerableSemigroup(gens) then 
    filts := filts and IsEnumerableSemigroupRep;
  fi;

  if IsMatrixObj(gens[1]) then #FIXME this clause should be unnecessary now
    filts := filts and IsMatrixOverFiniteFieldSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));
  SetGeneratorsOfMagma(S, AsList(gens));

  return S;
end);

InstallMethod(MonoidByGenerators,
"for a finite multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite],
function(gens)
  return MonoidByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(MonoidByGenerators,
"for a finite multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local mgens, pos, n, S, SemigroupsAddGenerators, filts, i, x;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);
  mgens := ShallowCopy(gens);

  if CanEasilyCompareElements(gens) or IsMatrixObj(gens[1]) then
    # Try to find a smaller generating set
    if opts.small and Length(gens) > 1 then
      gens := Shuffle(Set(gens));
      if IsGeneratorsOfActingSemigroup(gens) then
        n := ActionDegree(gens);
        Sort(gens, function(x, y)
                     return ActionRank(x, n) > ActionRank(y, n);
                   end);
      else
        Sort(gens, IsGreensDLeq(Semigroup(gens)));
      fi;

      opts         := ShallowCopy(opts);
      opts.small   := false;
      opts.regular := false;

      S := Monoid(gens[1], opts);

      SemigroupsAddGenerators := SEMIGROUPS.AddGenerators;

      if InfoLevel(InfoSemigroups) > 1 then
        n := Length(gens);
        for i in [2 .. n] do
          if not gens[i] in S then
            S := SemigroupsAddGenerators(S, [gens[i]], opts);
          fi;
          Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
                " generators so far\n");
        od;
      else
        for x in gens do
          if not x in S then
            S := SemigroupsAddGenerators(S, [x], opts);
          fi;
        od;
      fi;
      return S;
    elif IsMultiplicativeElementWithOneCollection(gens)
        and Length(gens) > 1 then
      pos := Position(gens, One(gens));
      if pos <> fail and
          (not IsPartialPermCollection(gens) or One(gens) =
           One(gens{Concatenation([1 .. pos - 1],
                                  [pos + 1 .. Length(gens)])})) then
        Remove(mgens, pos);
      fi;
    fi;
  fi;

  filts := IsMonoid and IsAttributeStoringRep;

  if opts.acting and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
    if opts.regular then
      filts := filts and IsRegularSemigroup;
    fi;
  elif IsGeneratorsOfEnumerableSemigroup(gens) then 
    filts := filts and IsEnumerableSemigroupRep;
  fi;

  if IsMatrixObj(gens[1]) then
    filts := filts and IsMatrixOverFiniteFieldSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));

  if CanEasilyCompareElements(gens) and not One(gens) in gens then
    SetGeneratorsOfMagma(S, Concatenation([One(gens)], gens));
  else
    SetGeneratorsOfMagma(S, AsList(gens));
  fi;

  SetGeneratorsOfMagmaWithOne(S, AsList(mgens));

  return S;
end);

InstallMethod(InverseSemigroupByGenerators,
"for a finite collection",
[IsCollection and IsFinite],
function(gens)
  return InverseSemigroupByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(InverseSemigroupByGenerators,
"for a finite multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local n, S, filts, i, x;

  if not IsGeneratorsOfInverseSemigroup(gens) then
    ErrorNoReturn("Semigroups: InverseSemigroupByGenerators: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);

  if CanEasilyCompareElements(gens) then
    # Check if the One of the generators is a generator
    if IsMultiplicativeElementWithOneCollection(gens)
        and Position(gens, One(gens)) <> fail then
      return InverseMonoidByGenerators(gens, opts);
    fi;

    # Try to find a smaller generating set
    if opts.small and Length(gens) > 1 then
      gens := Shuffle(Set(gens));
      if IsGeneratorsOfActingSemigroup(gens) then
        n := ActionDegree(gens);
        Sort(gens, function(x, y)
                     return ActionRank(x, n) > ActionRank(y, n);
                   end);
      else # Currently there is no way to enter this clause
        Sort(gens, IsGreensDLeq(InverseSemigroup(gens)));
      fi;

      opts := ShallowCopy(opts);
      opts.small := false;

      S := InverseSemigroup(gens[1], opts);

      if InfoLevel(InfoSemigroups) > 1 then
        n := Length(gens);
        for i in [2 .. n] do
          if not gens[i] in S then
            S := ClosureInverseSemigroupNC(S, [gens[i]], opts);
          fi;
          Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
                " generators so far\n");
        od;
      else
        for x in gens do
          if not x in S then
            S := ClosureInverseSemigroupNC(S, [x], opts);
          fi;
        od;
      fi;
      return S;
    fi;
  fi;

  filts := IsMagma and IsInverseSemigroup and IsAttributeStoringRep;

  if opts.acting and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  elif IsGeneratorsOfEnumerableSemigroup(gens) then 
    filts := filts and IsEnumerableSemigroupRep;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));
  SetGeneratorsOfInverseSemigroup(S, AsList(gens));

  return S;
end);

InstallMethod(InverseMonoidByGenerators,
"for a finite collection",
[IsCollection and IsFinite],
function(gens)
  return InverseMonoidByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(InverseMonoidByGenerators,
"for a finite multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsMultiplicativeElementWithOneCollection
 and IsFinite, IsRecord],
function(gens, opts)
  local pos, n, S, filts, i, x;

  if not IsGeneratorsOfInverseSemigroup(gens) then
    ErrorNoReturn("Semigroups: InverseMonoidByGenerators: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);

  if CanEasilyCompareElements(gens) then
    if (not IsPartialPermCollection(gens) or not opts.small)
        and IsMultiplicativeElementWithOneCollection(gens)
        and Length(gens) > 1 then
      pos := Position(gens, One(gens));
      if pos <> fail and
          (not IsPartialPermCollection(gens) or One(gens) =
           One(gens{Concatenation([1 .. pos - 1],
                                  [pos + 1 .. Length(gens)])})) then
        gens := ShallowCopy(gens);
        Remove(gens, pos);
      fi;
    fi;

    # Try to find a smaller generating set
    if opts.small and Length(gens) > 1 then
      gens := Shuffle(Set(gens));
      if IsGeneratorsOfActingSemigroup(gens) then
        n := ActionDegree(gens);
        Sort(gens, function(x, y)
                     return ActionRank(x, n) > ActionRank(y, n);
                   end);
      else # Currently there is no way to enter this clause
        Sort(gens, IsGreensDLeq(InverseMonoid(gens)));
      fi;

      opts := ShallowCopy(opts);
      opts.small := false;

      S := InverseMonoid(gens[1], opts);

      if InfoLevel(InfoSemigroups) > 1 then
        n := Length(gens);
        for i in [2 .. n] do
          if not gens[i] in S then
            S := ClosureInverseSemigroupNC(S, [gens[i]], opts);
          fi;
          Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
                " generators so far\n");
        od;
      else
        for x in gens do
          if not x in S then
            S := ClosureInverseSemigroupNC(S, [x], opts);
          fi;
        od;
      fi;
      return S;
    fi;
  fi;

  filts := IsMagmaWithOne and IsInverseSemigroup and IsAttributeStoringRep;

  if opts.acting and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  elif IsGeneratorsOfEnumerableSemigroup(gens) then 
    filts := filts and IsEnumerableSemigroupRep;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));
  SetOne(S, One(gens));

  if CanEasilyCompareElements(gens) and not One(gens) in gens then
    SetGeneratorsOfInverseSemigroup(S, Concatenation([One(gens)], gens));
  else
    SetGeneratorsOfInverseSemigroup(S, AsList(gens));
  fi;

  SetGeneratorsOfInverseMonoid(S, AsList(gens));
  return S;
end);

#############################################################################
## 4. RegularSemigroup
#############################################################################

InstallGlobalFunction(RegularSemigroup,
function(arg)
  if not IsRecord(arg[Length(arg)]) then
    Add(arg, rec(regular := true));
  else
    arg[Length(arg)].regular := true;
  fi;
  return CallFuncList(Semigroup, arg);
end);

#############################################################################
## 5. ClosureSemigroup and ClosureInverseSemigroup
#############################################################################

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op and finite multiplicative element coll",
[IsSemigroupWithInverseOp, IsMultiplicativeElementCollection and IsFinite],
function(S, coll) #FIXME is the ShallowCopy really necessary?
  return ClosureInverseSemigroup(S,
                                 coll,
                                 ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op and a multiplicative element",
[IsSemigroupWithInverseOp, IsMultiplicativeElement],
function(S, x) #FIXME is the ShallowCopy really necessary?
  return ClosureInverseSemigroup(S,
                                 [x],
                                 ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureInverseSemigroup,
"for semigroup with inverse op, multiplicative element, record",
[IsSemigroupWithInverseOp, IsMultiplicativeElement, IsRecord],
function(S, x, opts)
  return ClosureInverseSemigroup(S, [x], opts);
end);

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op, empty list or collection, and record",
[IsSemigroupWithInverseOp, IsListOrCollection and IsEmpty, IsRecord],
function(S, coll, opts)
  return S;
end);

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op, finite multiplicative elt coll, and record",
[IsSemigroupWithInverseOp, IsMultiplicativeElementCollection and IsFinite,
 IsRecord],
function(S, coll, opts)

  if IsSemigroup(coll) then
    coll := GeneratorsOfSemigroup(coll);
  elif not IsList(coll) then
    coll := AsList(coll);
  fi;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll))
      or not IsGeneratorsOfSemigroup(Concatenation(GeneratorsOfSemigroup(S),
                                                   coll)) then
    ErrorNoReturn("Semigroups: ClosureInverseSemigroup: usage,\n",
                  "the semigroup and collection of elements are not of the ",
                  "same type,");
  elif not IsGeneratorsOfInverseSemigroup(coll) then
    ErrorNoReturn("Semigroups: ClosureInverseSemigroup: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  coll := Set(coll);

  return ClosureInverseSemigroupNC(S,
                                   Filtered(coll, x -> not x in S),
                                   SEMIGROUPS.ProcessOptionsRec(opts));
end);

InstallGlobalFunction(ClosureInverseSemigroupNC,
function(S, coll, opts)
  local gens, T, o, n, x;

  if coll = [] then
    Info(InfoSemigroups, 2, "the elements in the collection belong to the ",
         "semigroup,");
    return S;
  elif not IsActingSemigroup(S) or IsSemigroupIdeal(S) then
    return InverseSemigroup(S, coll, opts);
  fi;

  if Length(coll) = 1 then
    gens := GeneratorsOfInverseSemigroup(S);
    T := InverseSemigroupByGenerators(Concatenation(gens, coll), opts);

    if not IsIdempotent(coll[1]) then
      Add(coll, coll[1] ^ -1);
    fi;

    o := StructuralCopy(LambdaOrb(S));
    AddGeneratorsToOrbit(o, coll);

    #remove everything related to strongly connected components
    Unbind(o!.scc);
    Unbind(o!.trees);
    Unbind(o!.scc_lookup);
    Unbind(o!.mults);
    Unbind(o!.schutz);
    Unbind(o!.reverse);
    Unbind(o!.rev);
    Unbind(o!.truth);
    Unbind(o!.schutzstab);
    Unbind(o!.factorgroups);
    Unbind(o!.factors);

    o!.parent := T;
    o!.scc_reps := [FakeOne(Generators(T))];

    SetLambdaOrb(T, o);
    return T;
  fi;

  Shuffle(coll);
  n := ActionDegree(coll);
  Sort(coll, function(x, y)
               return ActionRank(x, n) > ActionRank(y, n);
             end);

  opts.small := false;

  for x in coll do
    if not x in S then
      S := ClosureInverseSemigroupNC(S, [x], opts);
    fi;
  od;

  return S;
end);

InstallMethod(ClosureSemigroup,
"for a semigroup and finite multiplicative element collection",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite],
function(S, coll) #FIXME: ShallowCopy?
  return ClosureSemigroup(S, coll, ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureSemigroup, "for a semigroup and multiplicative element",
[IsSemigroup, IsMultiplicativeElement],
function(S, x) #FIXME: ShallowCopy
  return ClosureSemigroup(S, [x], ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureSemigroup,
"for a semigroup, multiplicative element, and record",
[IsSemigroup, IsMultiplicativeElement, IsRecord],
function(S, x, opts)
  return ClosureSemigroup(S, [x], opts);
end);

InstallMethod(ClosureSemigroup,
"for a semigroup, finite multiplicative element collection, and record",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(S, coll, opts)

  if IsSemigroup(coll) then
    coll := GeneratorsOfSemigroup(coll);
  elif not IsList(coll) then
    coll := AsList(coll);
  fi;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll))
      or not IsGeneratorsOfSemigroup(Concatenation(GeneratorsOfSemigroup(S),
                                                   coll)) then
    ErrorNoReturn("Semigroups: ClosureSemigroup: usage,\n",
                  "the semigroup and collection of elements are not of the ",
                  "same type,");
  fi;

  opts.small := false;

  return ClosureSemigroupNC(S,
                            Filtered(coll, x -> not x in S),
                            SEMIGROUPS.ProcessOptionsRec(opts));
end);

# This is the fallback method, coll should consist of elements not in
# the semigroup

InstallMethod(ClosureSemigroupNC,
"for a semigroup, finite multiplicative element collection, and record",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(S, coll, opts)
  local T;
  T := Semigroup(Concatenation(GeneratorsOfSemigroup(S), coll), opts);
  # The following does nothing if S / T is not an CPP semigroup
  return EN_SEMI_CLOSURE(T, S, coll);
end);

InstallMethod(ClosureSemigroupNC,
"for a semigroup, empty collection, and record",
[IsSemigroup, IsListOrCollection and IsEmpty, IsRecord],
function(S, coll, opts)
  return S;
end);

#############################################################################
## 6. Subsemigroups
#############################################################################

InstallMethod(SubsemigroupByProperty,
"for a semigroup, function, and positive integer",
[IsSemigroup, IsFunction, IsPosInt],
function(S, func, limit)
  local iter, x, T;

  iter := Iterator(S);

  repeat
    x := NextIterator(iter);
  until func(x) or IsDoneIterator(iter);

  if not func(x) then
    return fail; # should really return the empty semigroup
  fi;

  T := Semigroup(x);

  while Size(T) < limit and not IsDoneIterator(iter) do
    x := NextIterator(iter);
    if func(x) and not x in T then
      T := SEMIGROUPS.AddGenerators(T, [x], SEMIGROUPS.OptionsRec(T));
    fi;
  od;
  SetParent(T, S);
  return T;
end);

InstallMethod(InverseSubsemigroupByProperty,
"for a semigroup with inverse op, function, positive integer",
[IsSemigroupWithInverseOp, IsFunction, IsPosInt],
function(S, func, limit)
  local iter, T, x;

  iter := Iterator(S);

  repeat
    x := NextIterator(iter);
  until func(x) or IsDoneIterator(iter);

  if not func(x) then
    return fail; # should really return the empty semigroup
  fi;

  T := InverseSemigroup(x);

  while Size(T) < limit and not IsDoneIterator(iter) do
    x := NextIterator(iter);
    if func(x) then
      T := ClosureInverseSemigroup(T, x);
    fi;
  od;
  SetParent(T, S);
  return T;
end);

InstallMethod(SubsemigroupByProperty, "for a semigroup and function",
[IsSemigroup, IsFunction],
function(S, func)
  return SubsemigroupByProperty(S, func, Size(S));
end);

InstallMethod(InverseSubsemigroupByProperty,
"for semigroup with inverse op and function",
[IsSemigroupWithInverseOp, IsFunction],
function(S, func)
  return InverseSubsemigroupByProperty(S, func, Size(S));
end);

#############################################################################
## 7. Random semigroups and elements
#############################################################################

InstallMethod(Random,
"for a semigroup with AsList",
[IsSemigroup and HasAsList],
20, # to beat other random methods
function(S)
  return AsList(S)[Random([1 .. Size(S)])];
end);

InstallMethod(SEMIGROUPS_ProcessRandomArgsCons,
[IsSemigroup, IsList],
function(filt, params)
  if Length(params) < 1 then # nr gens
    params[1] := Random([1 .. 20]);
  elif not IsPosInt(params[1]) then
    return "the second argument (number of generators) must be a pos int,";
  fi;
  if Length(params) < 2 then # degree / dimension
    params[2] := Random([1 .. 20]);
  elif not IsPosInt(params[2]) then
    return "the third argument (degree or dimension) must be a pos int,";
  fi;
  if Length(params) > 2 then
    return "there must be at most three arguments,";
  fi;
  return params;
end);

InstallMethod(SEMIGROUPS_ProcessRandomArgsCons,
[IsMonoid, IsList],
function(filt, params)
  return SEMIGROUPS_ProcessRandomArgsCons(IsSemigroup, params);
end);

SEMIGROUPS.DefaultRandomInverseSemigroup := function(filt, params)
  if Length(params) = 2 then
    return AsSemigroup(filt,
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  elif Length(params) = 3 then
    return AsSemigroup(filt,
                       params[3], # threshold
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  elif Length(params) = 4 then
    return AsSemigroup(filt,
                       params[3], # threshold
                       params[4], # period
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  fi;
  ErrorNoReturn("Semigroups: SEMIGROUPS.DefaultRandomInverseSemigroup: ",
                "usage,\nthe second arg must have length 2 to 4,");
end;

SEMIGROUPS.DefaultRandomInverseMonoid := function(filt, params)
  if Length(params) = 2 then
    return AsMonoid(filt,
                    RandomInverseMonoid(IsPartialPermMonoid,
                                        params[1],
                                        params[2]));
  elif Length(params) = 3 then
    return AsMonoid(filt,
                    params[3], # threshold
                    RandomInverseMonoid(IsPartialPermMonoid,
                                        params[1],
                                        params[2]));
  elif Length(params) = 4 then
    return AsMonoid(filt,
                    params[3], # threshold
                    params[4], # period
                    RandomInverseMonoid(IsPartialPermMonoid,
                                        params[1],
                                        params[2]));
  fi;
  ErrorNoReturn("Semigroups: SEMIGROUPS.DefaultRandomInverseMonoid: usage,\n",
                "the second arg must have length 2 to 4,");
end;

# TODO RandomSource?

InstallGlobalFunction(RandomSemigroup,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
    if not IsFilter(filt) then
      ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n",
                    "the first argument must be a filter,");
    fi;
  else
    filt := Random([IsReesMatrixSemigroup,
                    IsReesZeroMatrixSemigroup,
                    IsFpSemigroup,
                    IsPBRSemigroup,
                    IsBipartitionSemigroup,
                    IsBlockBijectionSemigroup,
                    IsTransformationSemigroup,
                    IsPartialPermSemigroup,
                    IsBooleanMatSemigroup,
                    IsMaxPlusMatrixSemigroup,
                    IsMinPlusMatrixSemigroup,
                    IsTropicalMaxPlusMatrixSemigroup,
                    IsTropicalMinPlusMatrixSemigroup,
                    IsProjectiveMaxPlusMatrixSemigroup,
                    IsNTPMatrixSemigroup,
                    IsIntegerMatrixSemigroup,
                    IsMatrixOverFiniteFieldSemigroup]);
  fi;

  params := SEMIGROUPS_ProcessRandomArgsCons(filt, arg{[2 .. Length(arg)]});
  if IsString(params) then
    ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n", params);
  fi;
  return RandomSemigroupCons(filt, params);
end);

InstallGlobalFunction(RandomMonoid,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
    if not IsFilter(filt) then
      ErrorNoReturn("Semigroups: RandomMonoid: usage,\n",
                    "the first argument must be a filter,");
    fi;
  else
    filt := Random([IsFpMonoid,
                    IsPBRMonoid,
                    IsBipartitionMonoid,
                    IsTransformationMonoid,
                    IsPartialPermMonoid,
                    IsBooleanMatMonoid,
                    IsMaxPlusMatrixMonoid,
                    IsMinPlusMatrixMonoid,
                    IsTropicalMaxPlusMatrixMonoid,
                    IsTropicalMinPlusMatrixMonoid,
                    IsProjectiveMaxPlusMatrixMonoid,
                    IsNTPMatrixMonoid,
                    IsBlockBijectionMonoid,
                    IsIntegerMatrixMonoid,
                    IsMatrixOverFiniteFieldMonoid]);
  fi;

  params := SEMIGROUPS_ProcessRandomArgsCons(filt, arg{[2 .. Length(arg)]});
  if IsString(params) then
    ErrorNoReturn("Semigroups: RandomMonoid: usage,\n", params);
  fi;
  return RandomMonoidCons(filt, params);
end);

InstallGlobalFunction(RandomInverseSemigroup,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
    if not IsFilter(filt) then
      ErrorNoReturn("Semigroups: RandomInverseSemigroup: usage,\n",
                    "the first argument must be a filter,");
    fi;
  else
    filt := Random([IsFpSemigroup,
                    IsPBRSemigroup,
                    IsBipartitionSemigroup,
                    IsTransformationSemigroup,
                    IsPartialPermSemigroup,
                    IsBooleanMatSemigroup,
                    IsMaxPlusMatrixSemigroup,
                    IsMinPlusMatrixSemigroup,
                    IsTropicalMaxPlusMatrixSemigroup,
                    IsTropicalMinPlusMatrixSemigroup,
                    IsProjectiveMaxPlusMatrixSemigroup,
                    IsNTPMatrixSemigroup,
                    IsBlockBijectionSemigroup,
                    IsIntegerMatrixSemigroup,
                    IsMatrixOverFiniteFieldSemigroup]);
  fi;

  params := SEMIGROUPS_ProcessRandomArgsCons(filt, arg{[2 .. Length(arg)]});
  if IsString(params) then
    ErrorNoReturn("Semigroups: RandomInverseSemigroup: usage,\n", params);
  fi;
  return RandomInverseSemigroupCons(filt, params);
end);

InstallGlobalFunction(RandomInverseMonoid,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
    if not IsFilter(filt) then
      ErrorNoReturn("Semigroups: RandomInverseMonoid: usage,\n",
                    "the first argument must be a filter,");
    fi;
  else
    filt := Random([IsFpMonoid,
                    IsPBRMonoid,
                    IsBipartitionMonoid,
                    IsTransformationMonoid,
                    IsPartialPermMonoid,
                    IsBooleanMatMonoid,
                    IsMaxPlusMatrixMonoid,
                    IsMinPlusMatrixMonoid,
                    IsTropicalMaxPlusMatrixMonoid,
                    IsTropicalMinPlusMatrixMonoid,
                    IsProjectiveMaxPlusMatrixMonoid,
                    IsNTPMatrixMonoid,
                    IsBlockBijectionMonoid,
                    IsIntegerMatrixMonoid,
                    IsMatrixOverFiniteFieldMonoid]);
  fi;

  params := SEMIGROUPS_ProcessRandomArgsCons(filt, arg{[2 .. Length(arg)]});
  if IsString(params) then
    ErrorNoReturn("Semigroups: RandomInverseMonoid: usage,\n", params);
  fi;
  return RandomInverseMonoidCons(filt, params);
end);

#############################################################################
## 8. Changing representation: AsSemigroup, AsMonoid
#############################################################################

# IsomorphismSemigroup can be used to find an isomorphism from any semigroup to
# a semigroup of any other type (provided a method is installed!). This is done
# to avoid having to have an operation/attribute called IsomorphismXSemigroup
# for every single type of semigroup (X = Bipartition, MaxPlusMatrix, etc).
# This is simpler but has the disadvantage that the isomorphisms are not stored
# as attributes, and slightly more typing is required.
#
# The following IsomorphismXSemigroup functions remain:
#
# - IsomorphismTransformationSemigroup/Monoid
# - IsomorphismPartialPermSemigroup/Monoid
# - IsomorphismFpSemigroup/Monoid
# - IsomorphismRees(Zero)MatrixSemigroup
#
# since they are defined in the GAP library, and, in some sense, are
# fundamental and so it is desirable that they are stored as attributes. The
# method for IsomorphismSemigroup(IsTransformationSemigroup, S) delegates to
# IsomorphismTransformationSemigroup(S), and similarly for the other types
# listed above.
#
# If introducing a new type IsNewTypeOfSemigroup of semigroup, then the minimum
# requirement is to install a method for:
#
#     IsomorphismSemigroup(IsNewTypeOfSemigroup, IsTransformationSemigroup)
#
# and
#
#     InstallMethod(IsomorphismSemigroup,
#     "for IsNewTypeOfSemigroup and a semigroup",
#     [IsNewTypeOfSemigroup, IsSemigroup],
#     SEMIGROUPS.DefaultIsomorphismSemigroup);
#
# Since every other isomorphism can then be computed by composing with an
# isomorphism to a transformation semigroup. Of course, if a better method is
# known, then this can be installed instead. The default (right regular)
# isomorphism from a semigroup in IsNewTypeOfSemigroup to a transformation
# semigroup will be used, if no better method is installed.
#
# It is necessary that all of the methods for IsomorphismSemigroup in a given
# file have the same filter IsXSemigroup for the first argument.  (i.e.
# methods for IsomorphismSemgroup(IsXSemigroup, ...) must go in the
# corresponding file).  Also the methods for IsomorphismSemigroup must appear
# from lowest to highest rank due to the way that constructors are implemented.
# If they are not in lowest to highest rank order, then the wrong constructor
# method is selected (i.e.  the last applicable one is selected).
#
# IsomorphismMonoid is only really necessary to convert semigroups with
# MultiplicativeNeutralElement, which are not in IsMonoid, to monoids. For
# example,
#
#     gap> S := Monoid(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
#     >                Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
#     gap> AsSemigroup(IsBooleanMatSemigroup, S);
#     <monoid of 10x10 boolean matrices with 2 generators>
#     gap> AsMonoid(IsBooleanMatMonoid, S);
#     <monoid of 10x10 boolean matrices with 2 generators>
#     gap> S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
#     >                   Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
#     gap> AsSemigroup(IsBooleanMatSemigroup, S);
#     <semigroup of 10x10 boolean matrices with 2 generators>
#     gap> AsMonoid(IsBooleanMatMonoid, S);
#     <monoid of 8x8 boolean matrices with 2 generators>
#
# The reason that AsSemigroup(IsBooleanMatSemigroup, S) returns a monoid, is
# that in IsomorphismSemigroup the GeneratorsOfSemigroup(S) are used to
# construct generators <gens> for the isomorphic boolean matrix semigroup. But
# GeneratorsOfSemigroup(S) contains the One(S) (since it is a monoid) and so
# when we call Semigroup(gens), Semigroup detects that one of the generators is
# the One of the others, and so returns a monoid.
#
# Note also that in the example of semigroups of pbrs, there is a good
# (semigroup) embedding of the partition monoid, but not a good monoid
# embedding. So, if you do AsSemigroup(IsPBRSemigroup, S) when S is a
# bipartition monoid, it returns a semigroup of pbrs with degree equal to the
# degree of S, whereas if you do AsMonoid(IsPBRMonoid, S), you get a monoid
# where the degree is equal to the size of S plus 1 (since this is computed by
# computing an isomorphic transformation monoid, and then this is embedded, as
# a monoid, into a monoid of pbrs).

InstallMethod(AsSemigroup, "for a filter and a semigroup",
[IsFunction and IsOperation, IsSemigroup],
function(filt, S)

  if Tester(filt)(S) and filt(S) then
    return S;
  elif filt = IsTransformationSemigroup then
    return Range(IsomorphismTransformationSemigroup(S));
  elif filt = IsPartialPermSemigroup then
    return Range(IsomorphismPartialPermSemigroup(S));
  elif filt = IsReesMatrixSemigroup then
    return Range(IsomorphismReesMatrixSemigroup(S));
  elif filt = IsReesZeroMatrixSemigroup then
    return Range(IsomorphismReesZeroMatrixSemigroup(S));
  elif filt = IsFpSemigroup then
    return Range(IsomorphismFpSemigroup(S));
  fi;

  return Range(IsomorphismSemigroup(filt, S));
end);

InstallMethod(AsSemigroup, "for a filter, pos int, a semigroup",
[IsFunction and IsOperation, IsPosInt, IsSemigroup],
function(filt, threshold, S)
  return Range(IsomorphismSemigroup(filt, threshold, S));
end);

InstallMethod(AsSemigroup,
"for a filter, pos int, pos int, a semigroup",
[IsFunction and IsOperation, IsPosInt, IsPosInt, IsSemigroup],
function(filt, threshold, period, S)
  return Range(IsomorphismSemigroup(filt, threshold, period, S));
end);

InstallMethod(AsSemigroup, "for a filter, ring, and semigroup",
[IsFunction and IsOperation, IsRing, IsSemigroup],
function(filt, R, S)
  return Range(IsomorphismSemigroup(filt, R, S));
end);

InstallMethod(AsMonoid, "for a filter and a semigroup",
[IsFunction and IsOperation, IsSemigroup],
function(filt, S)

  if IsMonoid(S) and Tester(filt)(S) and filt(S) then
    return S;
  elif filt = IsTransformationMonoid then
    return Range(IsomorphismTransformationMonoid(S));
  elif filt = IsPartialPermMonoid then
    return Range(IsomorphismPartialPermMonoid(S));
  elif filt = IsFpMonoid then
    return Range(IsomorphismFpMonoid(S));
  fi;

  return Range(IsomorphismMonoid(filt, S));
end);

InstallMethod(AsMonoid, "for a filter, pos int, and a semigroup",
[IsFunction and IsOperation, IsPosInt, IsSemigroup],
function(filt, threshold, S)
  return Range(IsomorphismMonoid(filt, threshold, S));
end);

InstallMethod(AsMonoid,
"for a filter, pos int, pos int, and a semigroup",
[IsFunction and IsOperation, IsPosInt, IsPosInt, IsSemigroup],
function(filt, threshold, period, S)
  return Range(IsomorphismMonoid(filt, threshold, period, S));
end);

InstallMethod(AsMonoid, "for a filter, ring, and semigroup",
[IsFunction and IsOperation, IsRing, IsSemigroup],
function(filt, R, S)
  return Range(IsomorphismMonoid(filt, R, S));
end);
