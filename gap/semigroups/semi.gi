#############################################################################
##
#W  semi.gi
#Y  Copyright (C) 2013-15                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

#############################################################################
## This file contains methods for finite semigroups which do not depend on
## whether they are acting or not, i.e. they should work for all semigroups.
## It is organized as follows:
##
##   1. Helper functions
##
##   2. Generators
##
##   3. Semigroup/Monoid/InverseSemigroup/InverseMonoidByGenerators
##
##   4. RegularSemigroup
##
##   5. ClosureSemigroup and ClosureInverseSemigroup
##
##   6. Subsemigroups
##
##   7. Random semigroups and elements
##
##   8. Changing representation: AsSemigroup, AsMonoid
##
#############################################################################

#############################################################################
## 1. Helper functions
#############################################################################

# Returns an isomorphism from the semigroup <S> to a semigroup in <filter> by
# composing an isomorphism from <S> to a transformation semigroup <T> with an
# isomorphism from <T> to a semigroup in <filter>, i.e.  <filter> might be
# IsMaxPlusMatrixSemigroup or similar.

SEMIGROUPS.DefaultIsomorphismSemigroup := function(filter, S)
  local iso1, inv1, iso2, inv2;

  iso1 := IsomorphismTransformationSemigroup(S);
  inv1 := InverseGeneralMapping(iso1);
  iso2 := IsomorphismSemigroup(filter, Range(iso1));
  inv2 := InverseGeneralMapping(iso2);

  return MagmaIsomorphismByFunctionsNC(S,
                                       Range(iso2),
                                       x -> (x ^ iso1) ^ iso2,
                                       x -> (x ^ inv2) ^ inv1);
end;

# Returns an isomorphism from the monoid (or IsMonoidAsSemigroup) <S> to a
# monoid in <filter> by composing an isomorphism from <S> to a transformation
# monoid <T> with an isomorphism from <T> to a monoid in <filter>, i.e.
# <filter> might be IsMaxPlusMatrixMonoid or similar.

SEMIGROUPS.DefaultIsomorphismMonoid := function(filter, S)
  local iso1, inv1, iso2, inv2;

  iso1 := IsomorphismTransformationMonoid(S);
  inv1 := InverseGeneralMapping(iso1);
  iso2 := IsomorphismMonoid(filter, Range(iso1));
  inv2 := InverseGeneralMapping(iso2);

  return MagmaIsomorphismByFunctionsNC(S,
                                       Range(iso2),
                                       x -> (x ^ iso1) ^ iso2,
                                       x -> (x ^ inv2) ^ inv1);
end;

# Returns the semigroup generated by <S> and <coll> and may change <S> in
# place, so this should only be used in a function where <S> is created.

SEMIGROUPS.AddGenerators := function(S, coll, opts)
  local data;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll)) then
    ErrorNoReturn("Semigroups: SEMIGROUPS.AddGenerators: usage,\n",
                  "the arguments do not belong to the same family,");
  fi;

  if IsActingSemigroup(S)
      or (IsTransformationSemigroup(S) and DegreeOfTransformationSemigroup(S)
          <> DegreeOfTransformationCollection(coll))
      or (IsPartialPermSemigroup(S) and
          (DegreeOfPartialPermSemigroup(S) <>
           DegreeOfPartialPermCollection(coll)
           or CodegreeOfPartialPermSemigroup(S) <>
           CodegreeOfPartialPermCollection(coll)))
           ## FIXME the above should really be less than, since this should
           # work if the degree of the semigroup is larger than the degree of
           # the collection!
      or not SEMIGROUPS.IsCCSemigroup(S) then
    return ClosureSemigroup(S, coll, opts);
  fi;

  data := GenericSemigroupData(S);
  SEMIGROUP_ADD_GENERATORS(data, coll);
  S := Semigroup(data!.gens, opts);
  SetGenericSemigroupData(S, data);
  return S;
end;

#############################################################################
## 2. Generators
#############################################################################

InstallMethod(IsGeneratorsOfInverseSemigroup,
"for a semigroup with generators",
[IsSemigroup and HasGeneratorsOfSemigroup],
function(S)
  if IsSemigroupWithInverseOp(S) then
    return true;
  fi;
  return IsGeneratorsOfInverseSemigroup(GeneratorsOfSemigroup(S));
end);

InstallMethod(Generators, "for a semigroup",
[IsSemigroup],
function(S)

  if HasGeneratorsOfMagmaIdeal(S) then
    return GeneratorsOfMagmaIdeal(S);
  elif HasGeneratorsOfGroup(S) then
    return GeneratorsOfGroup(S);
  elif HasGeneratorsOfInverseMonoid(S) then
    return GeneratorsOfInverseMonoid(S);
  elif HasGeneratorsOfInverseSemigroup(S) then
    return GeneratorsOfInverseSemigroup(S);
  elif HasGeneratorsOfMonoid(S) then
    return GeneratorsOfMonoid(S);
  fi;

  return GeneratorsOfSemigroup(S);
end);

#############################################################################
## 3. Semigroup/Monoid/InverseSemigroup/InverseMonoidByGenerators
#############################################################################

InstallMethod(MagmaByGenerators, "for a multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite], SemigroupByGenerators);

InstallMethod(SemigroupByGenerators, "for a multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite],
function(coll)
  return SemigroupByGenerators(coll, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(SemigroupByGenerators,
"for a multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local n, S, SemigroupsAddGenerators, filts, pos, i, x;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);
  gens := AsList(gens);

  # try to find a smaller generating set
  if opts.small and Length(gens) > 1 then
    gens := Shuffle(SSortedList(gens)); #remove duplicates, permute
    if IsGeneratorsOfActingSemigroup(gens) then
      n := ActionDegree(gens);
      Sort(gens, function(x, y)
                   return ActionRank(x, n) > ActionRank(y, n);
                 end);
      #remove the identity
      if IsOne(gens[1]) and IsBound(gens[2])
          and ActionRank(gens[2], n) = n then
        Remove(gens, 1);
      fi;
    else
      Sort(gens, IsGreensDLeq(Semigroup(gens)));
      if IsMultiplicativeElementWithOneCollection(gens) and IsOne(gens[1])
          and gens[1] in Semigroup(gens[2]) then
        Remove(gens, 1);
      fi;
    fi;

    opts := ShallowCopy(opts);
    opts.small := false;
    opts.regular := false;
    S := Semigroup(gens[1], opts);

    SemigroupsAddGenerators := SEMIGROUPS.AddGenerators;

    if InfoLevel(InfoSemigroups) > 1 then
      n := Length(gens);
      for i in [2 .. n] do
        S := SemigroupsAddGenerators(S, [gens[i]], opts);
        Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
              " generators so far\r");
      od;
      Print("\n");
    else
      for x in gens do
        S := SemigroupsAddGenerators(S, [x], opts);
      od;
    fi;
    return S;
  fi;

  filts := IsSemigroup and IsAttributeStoringRep;

  if not opts.generic and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));

  if opts.regular then
    SetIsRegularSemigroup(S, true);
  fi;

  SetGeneratorsOfMagma(S, gens);

  if IsMultiplicativeElementWithOneCollection(gens)
      and CanEasilyCompareElements(gens)
      and IsFinite(gens) then
    pos := Position(gens, One(gens));
    if pos <> fail then
      SetFilterObj(S, IsMonoid);
      if Length(gens) = 1 then # Length(gens) <> 0 since One(gens) in gens
        SetIsTrivial(S, true);
      elif not IsPartialPermCollection(gens) or One(gens) =
          One(gens{Concatenation([1 .. pos - 1],
                                 [pos + 1 .. Length(gens)])}) then
        # if gens = [PartialPerm([1,2]), PartialPerm([1])], then removing the
        # One = gens[1] from this, it is not possible to recreate the semigroup
        # using Monoid(PartialPerm([1])) (since the One in this case is
        # PartialPerm([1]) not PartialPerm([1,2]) as it should be.
        gens := ShallowCopy(gens);
        Remove(gens, pos);
      fi;
      SetGeneratorsOfMonoid(S, gens);
    fi;
  fi;

  return S;
end);

InstallMethod(MonoidByGenerators, "for a multiplicative element collection",
[IsMultiplicativeElementCollection and IsFinite],
function(gens)
  return MonoidByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(MonoidByGenerators,
"for a multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local n, S, SemigroupsAddGenerators, filts, pos, i, x;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);
  gens := AsList(gens);

  if opts.small and Length(gens) > 1 then #small gen. set
    gens := Shuffle(SSortedList(gens));
    if IsGeneratorsOfActingSemigroup(gens) then
      n := ActionDegree(gens);
      Sort(gens, function(x, y)
                   return ActionRank(x, n) > ActionRank(y, n);
                 end);

      if IsOne(gens[1]) and IsBound(gens[2])
          and ActionRank(gens[2], n) = n then
        #remove id
        Remove(gens, 1);
      fi;
    else
      Sort(gens, IsGreensDLeq(Semigroup(gens)));
      if IsOne(gens[1]) and IsBound(gens[2])
          and gens[1] in Semigroup(gens[2]) then
        Remove(gens, 1);
      fi;
    fi;

    opts := ShallowCopy(opts);
    opts.small := false;
    opts.regular := false;
    S := Monoid(gens[1], opts);

    SemigroupsAddGenerators := SEMIGROUPS.AddGenerators;
    if InfoLevel(InfoSemigroups) > 1 then
      n := Length(gens);
      for i in [2 .. n] do
        if not gens[i] in S then
          S := SemigroupsAddGenerators(S, [gens[i]], opts);
        fi;
        Print("at \t", i, " of \t", n, "; \t", Length(Generators(S)),
              " generators so far");
      od;
      Print("\n");
    else
      for x in gens do
        if not x in S then
          S := SemigroupsAddGenerators(S, [x], opts);
        fi;
      od;
    fi;
    return S;
  fi;

  filts := IsMonoid and IsAttributeStoringRep;

  if not opts.generic and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));

  if opts.regular then
    SetIsRegularSemigroup(S, true);
  fi;

  # remove one from gens if it's there.
  if CanEasilyCompareElements(gens) and IsFinite(gens) then
    pos := Position(gens, One(gens));
    if pos <> fail then
      SetGeneratorsOfMagma(S, gens);
      if Length(gens) = 1 then # Length(gens) <> 0 since One(gens) in gens
        SetIsTrivial(S, true);
      elif not IsPartialPermCollection(gens) or One(gens) =
          One(gens{Concatenation([1 .. pos - 1],
                                 [pos + 1 .. Length(gens)])}) then
        # if gens = [PartialPerm([1,2]), PartialPerm([1])], then removing the
        # One = gens[1] from this, it is not possible to recreate the semigroup
        # using Monoid(PartialPerm([1])) (since the One in this case is
        # PartialPerm([1]) not PartialPerm([1,2]) as it should be.
        gens := ShallowCopy(gens);
        Remove(gens, pos);
      fi;
    else
      SetGeneratorsOfMagma(S, Concatenation([One(gens)], gens));
    fi;
  fi;
  SetGeneratorsOfMagmaWithOne(S, gens);
  return S;
end);

InstallMethod(InverseMonoidByGenerators,
"for a finite collection",
[IsCollection and IsFinite],
function(gens)
  return InverseMonoidByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(InverseSemigroupByGenerators,
"for a finite collection",
[IsCollection and IsFinite],
function(gens)
  return InverseSemigroupByGenerators(gens, SEMIGROUPS.DefaultOptionsRec);
end);

InstallMethod(InverseMonoidByGenerators,
"for a multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsMultiplicativeElementWithOneCollection
 and IsFinite, IsRecord],
function(gens, opts)
  local n, S, filts, one, pos, x;

  if not IsGeneratorsOfInverseSemigroup(gens) then
    ErrorNoReturn("Semigroups: InverseMonoidByGenerators: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);

  if opts.small and Length(gens) > 1 then
    gens := Shuffle(Set(gens));
    if IsGeneratorsOfActingSemigroup(gens) then
      n := ActionDegree(gens);
      Sort(gens, function(x, y)
                   return ActionRank(x, n) > ActionRank(y, n);
                 end);
    fi;
    opts := ShallowCopy(opts);
    opts.small := false;
    S := InverseMonoid(gens[1], opts);

    for x in gens do
      S := ClosureInverseSemigroup(S, x, opts);
    od;
    return S;
  fi;

  filts := IsMagmaWithOne and IsInverseSemigroup and IsAttributeStoringRep;

  if not opts.generic and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));
  one := One(gens);
  SetOne(S, one);
  gens := AsList(gens);

  if CanEasilyCompareElements(gens)
      and IsFinite(gens) then
    pos := Position(gens, one);
    if pos <> fail  then
      SetGeneratorsOfInverseSemigroup(S, gens);
      if Length(gens) = 1 then # Length(gens) <> 0 since One(gens) in gens
        SetIsTrivial(S, true);
      elif not IsPartialPermCollection(gens) or One(gens) =
          One(gens{Concatenation([1 .. pos - 1],
                                 [pos + 1 .. Length(gens)])}) then
        # if gens = [PartialPerm([1,2]), PartialPerm([1])], then removing the
        # One = gens[1] from this, it is not possible to recreate the semigroup
        # using Monoid(PartialPerm([1])) (since the One in this case is
        # PartialPerm([1]) not PartialPerm([1,2]) as it should be.
        gens := ShallowCopy(gens);
        Remove(gens, pos);
      fi;
      SetGeneratorsOfInverseMonoid(S, gens);
    else
      SetGeneratorsOfInverseMonoid(S, gens);
      gens := ShallowCopy(gens);
      Add(gens, one);
      SetGeneratorsOfInverseSemigroup(S, gens);
    fi;
  else
    SetGeneratorsOfInverseMonoid(S, gens);
  fi;

  return S;
end);

InstallMethod(InverseSemigroupByGenerators,
"for a multiplicative element collection and record",
[IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(gens, opts)
  local n, S, filts, pos, x;

  if not IsGeneratorsOfInverseSemigroup(gens) then
    ErrorNoReturn("Semigroups: InverseSemigroupByGenerators: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  opts := SEMIGROUPS.ProcessOptionsRec(opts);

  if opts.small and Length(gens) > 1 then
    gens := Shuffle(Set(gens));
    if IsGeneratorsOfActingSemigroup(gens) then
      n := ActionDegree(gens);
      Sort(gens, function(x, y)
                   return ActionRank(x, n) > ActionRank(y, n);
                 end);
    fi;

    opts := ShallowCopy(opts);
    opts.small := false;

    S := InverseSemigroup(gens[1], opts);
    for x in gens do
      if not x in S then
        S := ClosureInverseSemigroupNC(S, [x], opts);
      fi;
    od;
    return S;
  fi;

  filts := IsMagma and IsInverseSemigroup and IsAttributeStoringRep;

  if not opts.generic and IsGeneratorsOfActingSemigroup(gens) then
    filts := filts and IsActingSemigroup;
  fi;

  S := Objectify(NewType(FamilyObj(gens), filts), rec(opts := opts));
  gens := AsList(gens);
  SetGeneratorsOfInverseSemigroup(S, gens);

  if IsMultiplicativeElementWithOneCollection(gens)
      and CanEasilyCompareElements(gens)
      and IsFinite(gens) then
    pos := Position(gens, One(gens));
    if pos <> fail then
      SetFilterObj(S, IsMonoid);
      if Length(gens) = 1 then # Length(gens) <> 0 since One(gens) in gens
        SetIsTrivial(S, true);
      elif not IsPartialPermCollection(gens) or One(gens) =
          One(gens{Concatenation([1 .. pos - 1],
                                 [pos + 1 .. Length(gens)])}) then
        # if gens = [PartialPerm([1,2]), PartialPerm([1])], then removing the
        # One = gens[1] from this, it is not possible to recreate the semigroup
        # using Monoid(PartialPerm([1])) (since the One in this case is
        # PartialPerm([1]) not PartialPerm([1,2]) as it should be.
        gens := ShallowCopy(gens);
        Remove(gens, pos);
      fi;
      SetGeneratorsOfInverseMonoid(S, gens);
    fi;
  fi;

  return S;
end);

#############################################################################
## 4. RegularSemigroup
#############################################################################

InstallGlobalFunction(RegularSemigroup,
function(arg)
  if not IsRecord(arg[Length(arg)]) then
    Add(arg, rec(regular := true));
  else
    arg[Length(arg)].regular := true;
  fi;
  return CallFuncList(Semigroup, arg);
end);

#############################################################################
## 5. ClosureSemigroup and ClosureInverseSemigroup
#############################################################################

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op and multiplicative element coll.",
[IsSemigroupWithInverseOp, IsMultiplicativeElementCollection and IsFinite],
function(S, coll) #FIXME is the ShallowCopy really necessary?
  return ClosureInverseSemigroup(S,
                                 coll,
                                 ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op and a multiplicative element",
[IsSemigroupWithInverseOp, IsMultiplicativeElement],
function(S, x) #FIXME is the ShallowCopy really necessary?
  return ClosureInverseSemigroup(S,
                                 [x],
                                 ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureInverseSemigroup,
"for semigroup with inverse op, multiplicative element, record",
[IsSemigroupWithInverseOp, IsMultiplicativeElement, IsRecord],
function(S, x, opts)
  return ClosureInverseSemigroup(S, [x], opts);
end);

InstallMethod(ClosureInverseSemigroup,
"for a semigroup with inverse op, multiplicative elt coll, and record",
[IsSemigroupWithInverseOp, IsMultiplicativeElementCollection and IsFinite,
 IsRecord],
function(S, coll, opts)

  if IsEmpty(coll) then
    return S;
  fi;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll)) then
    ErrorNoReturn("Semigroups: ClosureInverseSemigroup: usage,\n",
                  "the semigroup and collection of elements are not of the ",
                  "same type,");
  fi;

  if not IsGeneratorsOfInverseSemigroup(coll) then
    ErrorNoReturn("Semigroups: ClosureInverseSemigroup: usage,\n",
                  "the first argument must satisfy ",
                  "`IsGeneratorsOfInverseSemigroup',");
  fi;

  if IsSemigroup(coll) then
    coll := GeneratorsOfSemigroup(coll);
  fi;

  coll := Set(coll);

  return ClosureInverseSemigroupNC(S,
                                   Filtered(coll, x -> not x in S),
                                   SEMIGROUPS.ProcessOptionsRec(opts));
end);

InstallGlobalFunction(ClosureInverseSemigroupNC,
function(S, coll, opts)
  local gens, T, o, n, x;

  if coll = [] then
    Info(InfoSemigroups, 2, "the elements in the collection belong to the ",
         "semigroup,");
    return S;
  elif not IsActingSemigroup(S) or IsSemigroupIdeal(S) then
    return InverseSemigroup(S, coll, opts);
  fi;

  if Length(coll) = 1 then
    gens := GeneratorsOfInverseSemigroup(S);
    T := InverseSemigroupByGenerators(Concatenation(gens, coll), opts);

    if not IsIdempotent(coll[1]) then
      Add(coll, coll[1] ^ -1);
    fi;

    o := StructuralCopy(LambdaOrb(S));
    AddGeneratorsToOrbit(o, coll);

    #remove everything related to strongly connected components
    Unbind(o!.scc);
    Unbind(o!.trees);
    Unbind(o!.scc_lookup);
    Unbind(o!.mults);
    Unbind(o!.schutz);
    Unbind(o!.reverse);
    Unbind(o!.rev);
    Unbind(o!.truth);
    Unbind(o!.schutzstab);
    Unbind(o!.factorgroups);
    Unbind(o!.factors);

    o!.parent := T;
    o!.scc_reps := [FakeOne(Generators(T))];

    SetLambdaOrb(T, o);
    return T;
  fi;

  Shuffle(coll);
  n := ActionDegree(coll);
  Sort(coll, function(x, y)
               return ActionRank(x, n) > ActionRank(y, n);
             end);

  opts.small := false;

  for x in coll do
    if not x in S then
      S := ClosureInverseSemigroupNC(S, [x], opts);
    fi;
  od;

  return S;
end);

InstallMethod(ClosureSemigroup,
"for a semigroup and multiplicative element collection",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite],
function(S, coll) #FIXME: ShallowCopy?
  return ClosureSemigroup(S, coll, ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureSemigroup, "for a semigroup and multiplicative element",
[IsSemigroup, IsMultiplicativeElement],
function(S, x) #FIXME: ShallowCopy
  return ClosureSemigroup(S, [x], ShallowCopy(SEMIGROUPS.OptionsRec(S)));
end);

InstallMethod(ClosureSemigroup,
"for a semigroup, multiplicative element, and record",
[IsSemigroup, IsMultiplicativeElement, IsRecord],
function(S, x, opts)
  return ClosureSemigroup(S, [x], opts);
end);

InstallMethod(ClosureSemigroup,
"for a semigroup, multiplicative element collection, and record",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(S, coll, opts)

  if IsEmpty(coll) then
    return S;
  fi;

  if ElementsFamily(FamilyObj(S)) <> FamilyObj(Representative(coll)) then
    ErrorNoReturn("Semigroups: ClosureSemigroup: usage,\n",
                  "the semigroup and collection of elements are not of the ",
                  "same type,");
  fi;

  if IsActingSemigroup(S)
      and IsActingSemigroupWithFixedDegreeMultiplication(S)
      and ActionDegree(S) <> ActionDegree(Representative(coll)) then
    ErrorNoReturn("Semigroups: ClosureSemigroup: usage,\n",
                  "the degree of the semigroup and collection must be equal,");
  fi;

  if IsSemigroup(coll) then
    coll := GeneratorsOfSemigroup(coll);
  fi;

  opts.small := false;

  return ClosureSemigroupNC(S,
                            Filtered(coll, x -> not x in S), # FIXME don't do
                                                             #       this
                            SEMIGROUPS.ProcessOptionsRec(opts));
end);

# this is the fallback method, coll should consist of elements not in
# the semigroup

InstallMethod(ClosureSemigroupNC,
"for a semigroup, multiplicative element collection, and record",
[IsSemigroup, IsMultiplicativeElementCollection and IsFinite, IsRecord],
function(S, coll, opts)
  local data, T;

  if SEMIGROUPS.IsCCSemigroup(S) then
    data := SEMIGROUP_CLOSURE(GenericSemigroupData(S),
                              ShallowCopy(coll),
                              SEMIGROUPS.DegreeOfSemigroup(S, coll));
    data := Objectify(NewType(FamilyObj(S), IsGenericSemigroupData and IsMutable
                                            and IsAttributeStoringRep), data);
    T := Semigroup(data!.gens, opts);
    SetGenericSemigroupData(T, data);
    data!.genstoapply := [1 .. Length(GeneratorsOfSemigroup(T))];
    return T;
  else
    Info(InfoWarning, 1, "using default method for ClosureSemigroupNC");
    return Semigroup(S, coll, opts);
  fi;
end);

InstallMethod(ClosureSemigroupNC,
"for a semigroup, empty collection, and record",
[IsSemigroup, IsListOrCollection and IsEmpty, IsRecord],
function(S, coll, opts)
  return S;
end);

#############################################################################
## 6. Subsemigroups
#############################################################################

InstallMethod(SubsemigroupByProperty,
"for a semigroup, function, and positive integer",
[IsSemigroup, IsFunction, IsPosInt],
function(S, func, limit)
  local iter, x, T;

  iter := Iterator(S);

  repeat
    x := NextIterator(iter);
  until func(x) or IsDoneIterator(iter);

  if not func(x) then
    return fail; # should really return the empty semigroup
  fi;

  T := Semigroup(x);

  while Size(T) < limit and not IsDoneIterator(iter) do
    x := NextIterator(iter);
    if func(x) and not x in T then
      T := SEMIGROUPS.AddGenerators(T, [x], SEMIGROUPS.OptionsRec(T));
    fi;
  od;
  SetParent(T, S);
  return T;
end);

InstallMethod(InverseSubsemigroupByProperty,
"for a semigroup with inverse op, function, positive integer",
[IsSemigroupWithInverseOp, IsFunction, IsPosInt],
function(S, func, limit)
  local iter, T, x;

  iter := Iterator(S);

  repeat
    x := NextIterator(iter);
  until func(x) or IsDoneIterator(iter);

  if not func(x) then
    return fail; # should really return the empty semigroup
  fi;

  T := InverseSemigroup(x);

  while Size(T) < limit and not IsDoneIterator(iter) do
    x := NextIterator(iter);
    if func(x) then
      T := ClosureInverseSemigroup(T, x);
    fi;
  od;
  SetParent(T, S);
  return T;
end);

InstallMethod(SubsemigroupByProperty, "for a semigroup and function",
[IsSemigroup, IsFunction],
function(S, func)
  return SubsemigroupByProperty(S, func, Size(S));
end);

InstallMethod(InverseSubsemigroupByProperty,
"for semigroup with inverse op and function",
[IsSemigroupWithInverseOp, IsFunction],
function(S, func)
  return InverseSubsemigroupByProperty(S, func, Size(S));
end);

#############################################################################
## 7. Random semigroups and elements
#############################################################################

InstallMethod(Random,
"for a semigroup with AsList",
[IsSemigroup and HasAsList],
20, # to beat other random methods
function(S)
  return AsList(S)[Random([1 .. Size(S)])];
end);

SEMIGROUPS.DefaultRandomInverseSemigroup := function(filt, params)
  if Length(params) = 2 then
    return AsSemigroup(filt,
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  elif Length(params) = 3 then
    return AsSemigroup(filt,
                       params[3], # threshold
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  elif Length(params) = 2 then
    return AsSemigroup(filt,
                       params[3], # threshold
                       params[4], # period
                       RandomInverseSemigroup(IsPartialPermSemigroup,
                                              params[1],
                                              params[2]));
  fi;
end;

SEMIGROUPS.DefaultRandomInverseMonoid := function(filt, params)
  if Length(params) = 2 then
    return AsMonoid(filt,
                       RandomInverseMonoid(IsPartialPermMonoid,
                                           params[1],
                                           params[2]));
  elif Length(params) = 3 then
    return AsMonoid(filt,
                       params[3], # threshold
                       RandomInverseMonoid(IsPartialPermMonoid,
                                           params[1],
                                           params[2]));
  elif Length(params) = 2 then
    return AsMonoid(filt,
                       params[3], # threshold
                       params[4], # period
                       RandomInverseMonoid(IsPartialPermMonoid,
                                           params[1],
                                           params[2]));
  fi;
end;

# TODO RandomSource?

InstallGlobalFunction(RandomSemigroup,
function(arg)
  local filt, params, order, i;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
  else
    filt := Random([IsReesMatrixSemigroup,
                    IsReesZeroMatrixSemigroup,
                    IsFpSemigroup,
                    IsPBRSemigroup,
                    IsBipartitionSemigroup,
                    IsBlockBijectionSemigroup,
                    IsTransformationSemigroup,
                    IsPartialPermSemigroup,
                    IsBooleanMatSemigroup,
                    IsMaxPlusMatrixSemigroup,
                    IsMinPlusMatrixSemigroup,
                    IsTropicalMaxPlusMatrixSemigroup,
                    IsTropicalMinPlusMatrixSemigroup,
                    IsProjectiveMaxPlusMatrixSemigroup,
                    IsNTPMatrixSemigroup,
                    IsIntegerMatrixSemigroup]);
  fi;

  if not IsFilter(filt) then
    ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n",
                  "the first argument must be a filter,");
  fi;

  params := [];

  if not ("IsReesMatrixSemigroup" in NamesFilter(filt)
          or "IsReesZeroMatrixSemigroup" in NamesFilter(filt)) then
    # using NamesFilter so that we can enter things like
    # IsReesZeroMatrixSemigroup and IsRegularSemigroup for filt.
    if Length(arg) >= 2 then # nr gens
      params[1] := arg[2];
    else
      params[1] := Random([1 .. 20]);
    fi;

    if filt <> IsFpSemigroup then
      if Length(arg) >= 3 then # dimension, degree
        params[2] := arg[3];
      else
        params[2] := Random([1 .. 20]);
      fi;
      if filt in [IsTropicalMaxPlusMatrixSemigroup,
                  IsTropicalMinPlusMatrixSemigroup,
                  IsNTPMatrixSemigroup] then
        if Length(arg) >= 4 then # threshold
          params[3] := arg[4];
        else
          params[3] := Random([1 .. 20]);
        fi;
        if filt = IsNTPMatrixSemigroup then
          if Length(arg) >= 5 then # period
            params[4] := arg[5];
          else
            params[4] := Random([1 .. 20]);
          fi;
        fi;
      fi;
    fi;
    # check params
    if ForAny(params, x -> not IsPosInt(x)) then
      ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n",
                    "the parameters must be positive integers,");
    fi;

    return RandomSemigroupCons(filt, params);
  else # filt is IsReesMatrixSemigroup or IsReesZeroMatrixSemigroup
    if Length(arg) >= 2 then # rows I
      params[1] := arg[2];
    else
      params[1] := Random([1 .. 100]);
    fi;
    if Length(arg) >= 3 then # cols J
      params[2] := arg[3];
    else
      params[2] := Random([1 .. 100]);
    fi;

    if Length(arg) >= 4 then # group
      params[3] := arg[4];
    else
      order := Random([1 .. 2047]);
      i := Random([1 .. NumberSmallGroups(order)]);
      params[3] := Range(IsomorphismPermGroup(SmallGroup(order, i)));
    fi;

    if Length(arg) > 4 then
      ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n",
                    "there should be at most 4 arguments,");
    fi;

    if not (IsPosInt(params[1]) and IsPosInt(params[2])
            and IsPermGroup(params[3])) then
      ErrorNoReturn("Semigroups: RandomSemigroup: usage,\n",
                    "the arguments should be rows, columns, and a perm ",
                    "group,");
    fi;
    return RandomSemigroupCons(filt, params);
  fi;
end);

InstallGlobalFunction(RandomMonoid,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
  else
    filt := Random([IsFpMonoid,
                    IsPBRMonoid,
                    IsBipartitionMonoid,
                    IsTransformationMonoid,
                    IsPartialPermMonoid,
                    IsBooleanMatMonoid,
                    IsMaxPlusMatrixMonoid,
                    IsMinPlusMatrixMonoid,
                    IsTropicalMaxPlusMatrixMonoid,
                    IsTropicalMinPlusMatrixMonoid,
                    IsProjectiveMaxPlusMatrixMonoid,
                    IsNTPMatrixMonoid,
                    IsBlockBijectionMonoid,
                    IsIntegerMatrixMonoid]);
  fi;

  if not IsFilter(filt) then
    ErrorNoReturn("Semigroups: RandomMonoid: usage,\n",
                  "the first argument must be a filter,");
  fi;

  params := [];

  if Length(arg) >= 2 then # nr gens
    params[1] := arg[2];
  else
    params[1] := Random([1 .. 20]);
  fi;

  if filt <> IsFpMonoid then
    if Length(arg) >= 3 then # dimension, degree
      params[2] := arg[3];
    else
      params[2] := Random([1 .. 20]);
    fi;
    if filt in [IsTropicalMaxPlusMatrixMonoid,
                IsTropicalMinPlusMatrixMonoid,
                IsNTPMatrixMonoid] then
      if Length(arg) >= 4 then # threshold
        params[3] := arg[4];
      else
        params[3] := Random([1 .. 20]);
      fi;
      if filt = IsNTPMatrixMonoid then
        if Length(arg) >= 5 then # period
          params[4] := arg[5];
        else
          params[4] := Random([1 .. 20]);
        fi;
      fi;
    fi;
  fi;
  # check params
  if ForAny(params, x -> not IsPosInt(x)) then
    ErrorNoReturn("Semigroups: RandomMonoid: usage,\n",
                  "the parameters must be positive integers,");
  fi;

  return RandomMonoidCons(filt, params);
end);

InstallGlobalFunction(RandomInverseSemigroup,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
  else
    filt := Random([IsFpSemigroup,
                    IsPBRSemigroup,
                    IsBipartitionSemigroup,
                    IsTransformationSemigroup,
                    IsPartialPermSemigroup,
                    IsBooleanMatSemigroup,
                    IsMaxPlusMatrixSemigroup,
                    IsMinPlusMatrixSemigroup,
                    IsTropicalMaxPlusMatrixSemigroup,
                    IsTropicalMinPlusMatrixSemigroup,
                    IsProjectiveMaxPlusMatrixSemigroup,
                    IsNTPMatrixSemigroup,
                    IsBlockBijectionSemigroup,
                    IsIntegerMatrixSemigroup]);
  fi;

  if not IsFilter(filt) then
    ErrorNoReturn("Semigroups: RandomInverseSemigroup: usage,\n",
                  "the first argument must be a filter,");
  fi;

  params := [];

  if Length(arg) >= 2 then # nr gens
    params[1] := arg[2];
  else
    params[1] := Random([1 .. 20]);
  fi;

  if filt <> IsFpSemigroup then
    if Length(arg) >= 3 then # dimension, degree
      params[2] := arg[3];
    else
      params[2] := Random([1 .. 20]);
    fi;
    if filt in [IsTropicalMaxPlusMatrixSemigroup,
                IsTropicalMinPlusMatrixSemigroup,
                IsNTPMatrixSemigroup] then
      if Length(arg) >= 4 then # threshold
        params[3] := arg[4];
      else
        params[3] := Random([1 .. 20]);
      fi;
      if filt = IsNTPMatrixSemigroup then
        if Length(arg) >= 5 then # period
          params[4] := arg[5];
        else
          params[4] := Random([1 .. 20]);
        fi;
      fi;
    fi;
  fi;
  # check params
  if ForAny(params, x -> not IsPosInt(x)) then
    ErrorNoReturn("Semigroups: RandomInverseSemigroup: usage,\n",
                  "the parameters must be positive integers,");
  fi;
  return RandomInverseSemigroupCons(filt, params);
end);

InstallGlobalFunction(RandomInverseMonoid,
function(arg)
  local filt, params;

  # check for optional first arg
  if Length(arg) >= 1 and IsPosInt(arg[1]) then
    CopyListEntries(arg, 1, 1, arg, 2, 1, Length(arg));
    Unbind(arg[1]);
  fi;

  if Length(arg) >= 1 and IsBound(arg[1]) then
    filt := arg[1];
  else
    filt := Random([IsFpMonoid,
                    IsPBRMonoid,
                    IsBipartitionMonoid,
                    IsTransformationMonoid,
                    IsPartialPermMonoid,
                    IsBooleanMatMonoid,
                    IsMaxPlusMatrixMonoid,
                    IsMinPlusMatrixMonoid,
                    IsTropicalMaxPlusMatrixMonoid,
                    IsTropicalMinPlusMatrixMonoid,
                    IsProjectiveMaxPlusMatrixMonoid,
                    IsNTPMatrixMonoid,
                    IsBlockBijectionMonoid,
                    IsIntegerMatrixMonoid]);
  fi;

  if not IsFilter(filt) then
    ErrorNoReturn("Semigroups: RandomInverseMonoid: usage,\n",
                  "the first argument must be a filter,");
  fi;

  params := [];

  if Length(arg) >= 2 then # nr gens
    params[1] := arg[2];
  else
    params[1] := Random([1 .. 20]);
  fi;

  if filt <> IsFpMonoid then
    if Length(arg) >= 3 then # dimension, degree
      params[2] := arg[3];
    else
      params[2] := Random([1 .. 20]);
    fi;
    if filt in [IsTropicalMaxPlusMatrixMonoid,
                IsTropicalMinPlusMatrixMonoid,
                IsNTPMatrixMonoid] then
      if Length(arg) >= 4 then # threshold
        params[3] := arg[4];
      else
        params[3] := Random([1 .. 20]);
      fi;
      if filt = IsNTPMatrixMonoid then
        if Length(arg) >= 5 then # period
          params[4] := arg[5];
        else
          params[4] := Random([1 .. 20]);
        fi;
      fi;
    fi;
  fi;
  # check params
  if ForAny(params, x -> not IsPosInt(x)) then
    ErrorNoReturn("Semigroups: RandomInverseMonoid: usage,\n",
                  "the parameters must be positive integers,");
  fi;
  return RandomInverseMonoidCons(filt, params);
end);

#############################################################################
## 8. Changing representation: AsSemigroup, AsMonoid
#############################################################################

# IsomorphismSemigroup can be used to find an isomorphism from any semigroup to
# a semigroup of any other type (provided a method is installed!). This is done
# to avoid having to have an operation/attribute called IsomorphismXSemigroup
# for every single type of semigroup (X = Bipartition, MaxPlusMatrix, etc).
# This is simpler but has the disadvantage that the isomorphisms are not stored
# as attributes, and slightly more typing is required.
#
# The following IsomorphismXSemigroup functions remain:
#
# - IsomorphismTransformationSemigroup/Monoid
# - IsomorphismPartialPermSemigroup/Monoid
# - IsomorphismFpSemigroup/Monoid
# - IsomorphismRees(Zero)MatrixSemigroup
#
# since they are defined in the GAP library, and, in some sense, are
# fundamental and so it is desirable that they are stored as attributes. The
# method for IsomorphismSemigroup(IsTransformationSemigroup, S) delegates to
# IsomorphismTransformationSemigroup(S), and similarly for the other types
# listed above.
#
# If introducing a new type IsNewTypeOfSemigroup of semigroup, then the minimum
# requirement is to install a method for:
#
#     IsomorphismSemigroup(IsNewTypeOfSemigroup, IsTransformationSemigroup)
#
# and
#
#     InstallMethod(IsomorphismSemigroup,
#     "for IsNewTypeOfSemigroup and a semigroup",
#     [IsNewTypeOfSemigroup, IsSemigroup],
#     SEMIGROUPS.DefaultIsomorphismSemigroup);
#
# Since every other isomorphism can then be computed by composing with an
# isomorphism to a transformation semigroup. Of course, if a better method is
# known, then this can be installed instead. The default (right regular)
# isomorphism from a semigroup in IsNewTypeOfSemigroup to a transformation
# semigroup will be used, if no better method is installed.
#
# It is necessary that all of the methods for IsomorphismSemigroup in a given
# file have the same filter IsXSemigroup for the first argument.  (i.e.
# methods for IsomorphismSemgroup(IsXSemigroup, ...) must go in the
# corresponding file).  Also the methods for IsomorphismSemigroup must appear
# from lowest to highest rank due to the way that constructors are implemented.
# If they are not in lowest to highest rank order, then the wrong constructor
# method is selected (i.e.  the last applicable one is selected).
#
# IsomorphismMonoid is only really necessary to convert semigroups with
# MultiplicativeNeutralElement, which are not in IsMonoid, to monoids. For
# example,
#
#     gap> S := Monoid(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
#     >                Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
#     gap> AsSemigroup(IsBooleanMatSemigroup, S);
#     <monoid of 10x10 boolean matrices with 2 generators>
#     gap> AsMonoid(IsBooleanMatMonoid, S);
#     <monoid of 10x10 boolean matrices with 2 generators>
#     gap> S := Semigroup(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),
#     >                   Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;
#     gap> AsSemigroup(IsBooleanMatSemigroup, S);
#     <semigroup of 10x10 boolean matrices with 2 generators>
#     gap> AsMonoid(IsBooleanMatMonoid, S);
#     <monoid of 8x8 boolean matrices with 2 generators>
#
# The reason that AsSemigroup(IsBooleanMatSemigroup, S) returns a monoid, is
# that in IsomorphismSemigroup the GeneratorsOfSemigroup(S) are used to
# construct generators <gens> for the isomorphic boolean matrix semigroup. But
# GeneratorsOfSemigroup(S) contains the One(S) (since it is a monoid) and so
# when we call Semigroup(gens), Semigroup detects that one of the generators is
# the One of the others, and so returns a monoid.
#
# Note also that in the example of semigroups of pbrs, there is a good
# (semigroup) embedding of the partition monoid, but not a good monoid
# embedding. So, if you do AsSemigroup(IsPBRSemigroup, S) when S is a
# bipartition monoid, it returns a semigroup of pbrs with degree equal to the
# degree of S, whereas if you do AsMonoid(IsPBRMonoid, S), you get a monoid
# where the degree is equal to the size of S plus 1 (since this is computed by
# computing an isomorphic transformation monoid, and then this is embedded, as
# a monoid, into a monoid of pbrs.

InstallMethod(AsSemigroup, "for a filter and a semigroup",
[IsFunction and IsOperation, IsSemigroup],
function(filt, S)

  if filt = IsTransformationSemigroup then
    return Range(IsomorphismTransformationSemigroup(S));
  elif filt = IsPartialPermSemigroup then
    return Range(IsomorphismPartialPermSemigroup(S));
  elif filt = IsReesMatrixSemigroup then
    return Range(IsomorphismReesMatrixSemigroup(S));
  elif filt = IsReesZeroMatrixSemigroup then
    return Range(IsomorphismReesZeroMatrixSemigroup(S));
  elif filt = IsFpSemigroup then
    return Range(IsomorphismFpSemigroup(S));
  fi;

  return Range(IsomorphismSemigroup(filt, S));
end);

InstallMethod(AsSemigroup, "for a filter, pos int, a semigroup",
[IsFunction and IsOperation, IsPosInt, IsSemigroup],
function(filt, threshold, S)
  return Range(IsomorphismSemigroup(filt, threshold, S));
end);

InstallMethod(AsSemigroup,
"for a filter, pos int, pos int, a semigroup",
[IsFunction and IsOperation, IsPosInt, IsPosInt, IsSemigroup],
function(filt, threshold, period, S)
  return Range(IsomorphismSemigroup(filt, threshold, period, S));
end);

InstallMethod(AsMonoid, "for a filter and a semigroup",
[IsFunction and IsOperation, IsSemigroup],
function(filt, S)

  if filt = IsTransformationMonoid then
    return Range(IsomorphismTransformationMonoid(S));
  elif filt = IsPartialPermMonoid then
    return Range(IsomorphismPartialPermMonoid(S));
  elif filt = IsFpMonoid then
    return Range(IsomorphismFpMonoid(S));
  fi;

  return Range(IsomorphismMonoid(filt, S));
end);

InstallMethod(AsMonoid, "for a filter, pos int, and a semigroup",
[IsFunction and IsOperation, IsPosInt, IsSemigroup],
function(filt, threshold, S)
  return Range(IsomorphismMonoid(filt, threshold, S));
end);

InstallMethod(AsMonoid,
"for a filter, pos int, pos int, and a semigroup",
[IsFunction and IsOperation, IsPosInt, IsPosInt, IsSemigroup],
function(filt, threshold, period, S)
  return Range(IsomorphismMonoid(filt, threshold, period, S));
end);
